<html>

<head>

<title>Adam Mark - Clustering markers on a warehouse map</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<meta name="title" content="Adam Mark - Clustering markers on a warehouse map"/>

<link href="../main.css?1684708627937" rel="stylesheet">

</head>

<body>

<main>

<a href="../">Home</a>

<h1>Clustering markers on a warehouse map</h1>

<h2>Adam Mark</h2>

<section>
<h3>Background</h3>

<p>From 2020 to 2023, I developed dashboards and mapping tools for a warehouse automation system using TypeScript, React, SVG and Canvas.</p>
</section>

<section>
<h3>Problem</h3>

<p>Our custom mapping system supported the arbitrary placement of "markers." Sometimes these markers would overlap, obscuring their values, as shown below. <i>Our map developers needed a way to eliminate this clutter.</i></p>

<p><img src="https://user-images.githubusercontent.com/28193/214857037-b0d11683-4458-4440-8edd-2691b927aa4d.png" width="100%"/></p>

</section>

<section>
<h3>Solution</h3>

<p>I created a simple clustering function that takes a set of <b>inputs</b>, each having a <i>coordinate</i> and <i>count</i>, and returns a smaller set of <b>outputs</b>, each having a <i>coordinate</i> and <i>count</i>. Then I could render exactly one marker per output:</p>

<p><img src="https://user-images.githubusercontent.com/28193/214858499-f3bda57d-5dbb-4b3e-a6a7-16e88c4db2d4.png" width="100%"/></p>

<p>Here's the effect:</p>

<p><video src="https://github.com/adammark/adammark.github.com/assets/28193/2ce66869-790f-4492-add9-90d81585ab49" width="100%" controls/></p>
</section>

<section>
<h3>The code</h3>

<p>First, I created an <b>Input</b> type to represent a unit of data on the map:</p>

<pre><code class="language-typescript hljs"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Input</span> = {
  <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span>;
  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">metadata?</span>: <span class="hljs-built_in">unknown</span>;
};</code>
</pre>

<p>Then I created an <b>Output</b> type, which takes the same shape as an <b>Input</b> yet also retains a reference to its constituent inputs:</p>

<pre><code class="language-typescript hljs"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-title class_">Input</span> &amp; {
  <span class="hljs-attr">inputs</span>: <span class="hljs-title class_">Input</span>[];
};</code>
</pre>

<p>Then I created a utility function that accepts an array of <b>inputs</b>, the current <b>scale</b> of the map, and a search <b>radius</b> (a larger radiusÂ packs more data). It returns a smaller array of <b>outputs</b>:</p>

<pre><code class="language-typescript hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cluster</span>(<span class="hljs-params">inputs: <span class="hljs-title class_">Input</span>[], scale: <span class="hljs-built_in">number</span>, radius: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Output</span>[] {
  ...
  <span class="hljs-keyword">return</span> outputs;
}</code>
</pre>

<p>Finally, with just a few lines of code, I was able to eliminate the clutter in a data-intensive map. Below, the map displays one "pin" per <b>output</b>:</p>

<pre><code class="language-typescript hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DemoMap</span>(<span class="hljs-params"></span>) {
  ...

  <span class="hljs-keyword">const</span> [scale, setScale] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> pinSize = <span class="hljs-number">5</span>;
  <span class="hljs-keyword">const</span> radius = pinSize * <span class="hljs-number">1.5</span>;
  <span class="hljs-keyword">const</span> inputs: <span class="hljs-title class_">Input</span>[] = data;
  <span class="hljs-keyword">const</span> outputs: <span class="hljs-title class_">Output</span>[] = <span class="hljs-title function_">cluster</span>(inputs, scale, radius);

  <span class="hljs-keyword">const</span> pins = outputs.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">output</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Annotation</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{output.key}</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{output.point.x}</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{output.point.y}</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">"ignore"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Pin</span> <span class="hljs-attr">color</span>=<span class="hljs-string">{Color.Blue}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{output.count}</span> <span class="hljs-attr">size</span>=<span class="hljs-string">{pinSize}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Annotation</span>&gt;</span></span>
    );
  });

  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;<span class="hljs-name">Map</span> <span class="hljs-attr">onZoom</span>=<span class="hljs-string">{(evt) =&gt; setScale(evt.scale)}</span> ...&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">g</span>&gt;</span>{pins}<span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Map</span>&gt;</span>
  );
}</code>
</pre>

</section>

<section>
<h3>Conclusion</h3>

<p>My utility function was a straightforward solution to a sticky problem. In the next version, I'd like to support different <i>types</i> of inputs at the same time.</p>
</section>

</main>

</body>

</html>
