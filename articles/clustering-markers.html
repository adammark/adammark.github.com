<html>

<head>

<title>Adam Mark - Clustering markers on a warehouse map</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<meta name="title" content="Adam Mark - Clustering markers on a warehouse map"/>

<link href="../main.css?1684601839395" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

</head>

<body>

<main>

<a href="../">Home</a>

<h1>Clustering markers on a warehouse map</h1>

<h2>Adam Mark</h2>

<section>
<h3>Background</h3>

<p>From 2020 to 2023, I developed dashboards and mapping tools for a warehouse automation system using TypeScript, React, SVG and Canvas.</p>
</section>

<section>
<h3>Problem</h3>

<p>Our mapping system supported the arbitrary placement of "markers." Sometimes these markers would overlap, obscuring their values, as shown below. <i>Map makers needed a way to eliminate this clutter.</i></p>

<p><img src="https://user-images.githubusercontent.com/28193/214857037-b0d11683-4458-4440-8edd-2691b927aa4d.png" width="100%"/></p>

</section>

<section>
<h3>Solution</h3>

<p>I created a simple clustering function that takes a set of <b>inputs</b>, each having a <i>coordinate</i> and <i>count</i>, and returns a set of <b>outputs</b>, each having a <i>coordinate</i> and <i>count</i>. Then I could render exactly one marker per output:</p>

<p><img src="https://user-images.githubusercontent.com/28193/214858499-f3bda57d-5dbb-4b3e-a6a7-16e88c4db2d4.png" width="100%"/></p>

<p>Here's the effect:</p>

<p><video src="https://github.com/adammark/adammark.github.com/assets/28193/2ce66869-790f-4492-add9-90d81585ab49" width="100%" controls/></p>
</section>

<section>
<h3>The code</h3>

<p>An <b>Input</b> represents a single bit of data: its location (point), its value (count), an identifier (key) and some optional metadata:</p>

<pre>
<code class="language-typescript">
type Input = {
  key: string;
  point: Point;
  count: number;
  metadata?: unknown;
};
</code>
</pre>

<p>An <b>Output</b> takes the same shape as an <b>Input</b> yet also retains a reference to its constituent inputs:</p>

<pre>
<code class="language-typescript">
type Output = Input & {
  inputs: Input[];
};
</code>
</pre>
  
<p>The clustering function itself accepts an array of <b>inputs</b>, the current <b>scale</b> of the map, and a search <b>radius</b> (a larger radiusÂ packs more data). It returns an array of <b>outputs</b>:</p>

<pre>
<code class="language-typescript">
function cluster(inputs: Input[], scale: number, radius: number): Output[] {
  ...
  return outputs;  
}
</code>
</pre>

<p>Now we can use the <b>outputs</b> of the cluster function to drop "pins" on the map:</p>

<pre>
<code class="language-typescript">
function DemoDashboard() {
  ...

  const [scale, setScale] = useState(1);
  const inputs: Input[] = data;
  const pinSize = 5;
  const radius = pinSize * 1.5;
  const outputs: Output[] = cluster(inputs, scale, radius);

  const annotations = outputs.map((output) => {
    return (
      &lt;Annotation key={output.key} x={output.point.x} y={output.point.y} scale="ignore"&gt;
        &lt;Pin color={Color.Blue} value={output.count} size={pinSize} /&gt;
      &lt;/Annotation&gt;
    );
  });

  return (
    &lt;Dashboard&gt;
      &lt;Map onZoom={(evt) => setScale(evt.scale)} ...&gt;
        &lt;g&gt;{annotations}&lt;/g&gt;
      &lt;/Map&gt;
    &lt;/Dashboard&gt;
  );
}
</code>
</pre>
</section>

<section>
<h3>Conclusion</h3>

<p>My utility function was a straightforward solution to a sticky problem. In the next version, I'd like to support different <i>types</i> of inputs at the same time.</p>
</section>

</main>

<script>
Array.from(document.querySelectorAll("code")).forEach((elem) => {
  elem.innerHTML = elem.innerHTML.trim();
});

hljs.highlightAll();
</script>

</body>

</html>
