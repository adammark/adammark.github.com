<html>

<head>

<title>Adam Mark - Improving map performance with Canvas</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<meta name="title" content="Adam Mark - Improving map performance with Canvas"/>

<link href="../main.css?1685368683753" rel="stylesheet">

</head>

<body>

<main>

<a href="../">Home</a>

<h1>Improving map performance with Canvas</h1>

<h2>Adam Mark</h2>

<section>
<h3>Background</h3>

<p>From 2020 to 2023, I developed dashboards and mapping tools for a warehouse automation system using TypeScript, React and SVG.</p>
</section>

<section>
<h3>Problem</h3>

<p>Our custom mapping system was built with SVG. While SVG was versatile and worked nicely with React, it showed strain when we tried to render more than a few hundred elements at once. <i>We needed a performant way to create complex data visualizations like heat maps.</i></p>

</section>

<section>
<h3>Solution</h3>

<p>I added a drawing surface to the map using the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>, along with utility methods for working with the map's coordinate system. This allowed us to draw thousands of individual elements on the screen without sacrificing performance, as shown in the following examples:</p>

<p><img src="https://user-images.githubusercontent.com/28193/216771249-da851b28-9591-4327-a696-891a3a9414cc.png" width="100%"/></p>

<p><img src="https://user-images.githubusercontent.com/28193/216777398-ec513b0e-efa9-4540-9bc2-b93bf8f55a02.png" width="100%"/></p>

<p>The following demo illustrates the performance power of Canvas. As the user zooms in and out, the canvas redraws 1,000 circles up to <b>50 times per second</b>:</p>

<p><video src="https://github.com/adammark/adammark.github.com/assets/28193/05e3d950-a0e4-4500-b170-81129565be58" width="100%" controls/></p>

</section>

<section>
<h3>The code</h3>

<p>First, I created a hook in the map library that allows client applications to access the drawing context:</p>

<pre><code class="language-typescript hljs"><span class="hljs-keyword">const</span> canvas = useMapCanvas();
<span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);</code></pre>

<p>Then I added a callback function to the Map component that allows client applications to respond to zoom and pan events:</p>

<pre><code class="language-typescript hljs">&lt;<span class="hljs-name">Map</span>
  <span class="hljs-attr">mapStack</span>=<span class="hljs-string">{...}</span>
  <span class="hljs-attr">onZoom</span>=<span class="hljs-string">{(evt) =&gt; ...}</span>
/&gt;
</code></pre>

<p>Finally, I implemented a drawing function in the client application that runs whenever the user manipulates the map. Putting it all together:</p>

<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { Map, useMapCanvas, resetMapContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'map-element'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DemoMap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> canvas = useMapCanvas();
  <span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);
  <span class="hljs-keyword">const</span> data = ...;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">context: CanvasRenderingContext2D, scale: number, center: Point, size: Size</span>) </span>{
    requestAnimationFrame(() =&gt; {
      resetMapContext(context, scale, center, dimensions, <span class="hljs-literal">true</span>);
  
      data.forEach((d) =&gt; {
        context.fillStyle = ...;
        context.beginPath();
        context.arc(d.x, d.y, d.radius, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI);
        context.fill();
      });
    });
  }

  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;<span class="hljs-name">Map</span>
      <span class="hljs-attr">mapStack</span>=<span class="hljs-string">{...}</span>
      <span class="hljs-attr">onZoom</span>=<span class="hljs-string">{(evt) =&gt; draw(context, evt.scale, evt.center, evt.size)}</span>
    /&gt;
  );
}</span>
</code></pre>
<section>

<section>
<h3>Conclusion</h3>

<p>Adding a canvas layer to the map opened the door to all kinds of interesting data visualizations. While SVG excelled at rendering basic map features, Canvas allowed us to render almost anything, and fast!</p>
</section>

</main>

</body>

</html>
