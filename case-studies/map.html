<html>

<head>

<title>Adam Mark - rMarker clustering</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<meta name="title" content="Adam Mark - rMarker clustering"/>

<link href="../main.css?1684525053608" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

</head>

<body>

<main>

<a href="../">Home</a>

<h1>Marker clustering</h1>

<h2>Adam Mark, May 2023</h2>

<section>
<h3>Background</h3>

<p>From 2020 to 2023, I developed dashboards and mapping tools for a warehouse automation system using TypeScript, React, SVG and Canvas.</p>
</section>

<section>
<h3>Problem</h3>

<p>I was building a feature that allowed map makers to decorate maps with various types of "markers." Sometimes these markers would overlap, obscuring their values, as shown in the following example:</p>

<p><img src="https://user-images.githubusercontent.com/28193/214857037-b0d11683-4458-4440-8edd-2691b927aa4d.png" width="100%"/></p>

<p>So I needed a way to <i>cluster</i> markers together.</p>

</section>

<section>
<h3>Solution</h3>

<p>I created a simple clustering function that takes a set of <b>inputs</b>, each having a <i>coordinate</i> and <i>count</i>, and returns a set of <b>outputs</b>, each having a <i>coordinate</i> and <i>count</i>. Then I could render exactly one marker (a Pin component) per output:</p>

<p><img src="https://user-images.githubusercontent.com/28193/214858499-f3bda57d-5dbb-4b3e-a6a7-16e88c4db2d4.png" width="100%"/></p>

<p>The function also accepts the <b>scale</b> of the map (the map can zoom in and out but the marker maintains a fixed size) and a search <b>radius</b> (the acceptable distance from one marker to another).</p>

<p>Here's the effect:</p>

<p><video src="https://github.com/adammark/adammark.github.com/assets/28193/2ce66869-790f-4492-add9-90d81585ab49" width="100%" controls/></p>
</section>

<p>Finally, each <b>output</b> holds a reference to its corresponding <b>inputs</b> in case the marker should reveal more detail when the user selects it.</p>

<section>
<h3>The code</h3>

<p>The following code transforms a set of <b>inputs</b> into a smaller set of <b>outputs</b>:</p>

<pre>
<code class="language-typescript">
export type Input = {
  key: string;
  point: Point;
  count: number;
  metadata?: unknown;
};

export type Output = Input & {
  inputs: Input[];
};

/**
 * This is a simple data clustering algorithm. It takes a set of inputs and
 * packs them together into a smaller set of outputs. Each output contains a
 * reference to all its inputs and can be used to render a "pin" on the map.
 *
 * The value of `scale` comes from the `&lt;Map&gt;` element. The value of `radius`
 * (in meters) is defined by you and is essentially a measure of how
 * aggressively you want to pack data points. A larger radius generates fewer
 * clusters. As a rule, the radius should roughly correspond to the size of
 * the graphic you intend to display. For example, if you're dropping pins on
 * the map, and each pin is 5x5, a reasonable radius to ensure breathing room
 * between pins would be 7.5, or about 150% of the width or height of the
 * graphic, whichever is greater.
 */
export function cluster(inputs: Input[], scale: number, radius: number): Output[] {
  const outputs: Output[] = [];
  const keys = new Set&lt;string&gt;();
  
  const grouped: Output[] = inputs.map((a, i) => {
    return {
      ...a,
      inputs: inputs.slice(i).filter((b) => {
        return distance(a.point, b.point) < radius / (scale / 3);
      }),
    };
  });
  
  while (grouped.length) {
    const [output] = grouped.splice(0, 1);
  
    if (!keys.has(output.key)) {
      outputs.push(output);
      output.inputs = output.inputs.filter((s) => {
        return !keys.has(s.key);
      });
  
      keys.add(output.key);

      output.inputs.forEach((input) => {
        keys.add(input.key);
      });
    }
  }
  
  return outputs.map((output) => {
    const inputs = output.inputs;
    const key = inputs.map((d) => d.key).join(',');
    const count = sum(inputs, 'count');
  
    const points = inputs.map((d) => d.point);
    const x = extent(points, 'x');
    const y = extent(points, 'y');

    // the center point of the cluster
    const point: Point = {
      x: (x[0] + x[1]) / 2,
      y: (y[0] + y[1]) / 2,
    };
  
    return {
      key,
      point,
      count,
      inputs,
    };
  });
}
</code>
</pre>

<p>Now to put it together. The following code passes 300 random <b>inputs</b> into the clustering function, then renders pins from the resulting <b>outputs</b>:</p>

<pre>
<code class="language-typescript">
export function MapDemo() {
  ... 

  // scale of the map
  const [scale, setScale] = useState(3);

  // random input data
  const inputs: Input[] = new Array(300).fill(0).map((_, i) => {
    const x = 50 + Math.random() * 100;
    const y = 5 + Math.random() * 50;
  
    return {
      key: i.toString(),
      point: { x, y },
      count: 1,
    };
  });

  // size of a pin
  const pinSize = 5;

  // search radius
  const radius = pinSize * 1.5;

  // clustered output data
  const outputs: Output[] = cluster(inputs, scale, radius);

  // pin components
  const pins = outputs.map((output) => {
    return (
      &lt;Annotation key={output.key} x={output.point.x} y={output.point.y} scale="ignore"&gt;
        &lt;Pin color={Color.Blue} value={output.count} size={pinSize} /&gt;
      &lt;/Annotation&gt;
    );
  });

  return (
    &lt;Dashboard&gt;
      &lt;Map onZoom={(evt) => setScale(evt.scale)} ...&gt;
        &lt;g&gt;{pins}&lt;/g&gt;
      &lt;/Map&gt;
    &lt;/Dashboard&gt;
  );
}
</code>
</pre>

<section>
  <h3>Conclusion</h3>

  <p>My code served a specific purpose: clustering a limited number of data points of the same type. Here's where it could be improved:</p>

  <ul>
    <li><p>It could handle different <i>types</i> of inputs such that the map could display <i>apple</i> clusters and <i>orange</i> clusters at the same time.</p></li>

    <li><p>It could use a grid-based algorithm for performance. Currently it has O(nÂ²) complexity and would degrade if given thousands of inputs.</p></li>
  </ul>
</section>

</main>

<script>
Array.from(document.querySelectorAll("code")).forEach((elem) => {
  elem.innerHTML = elem.innerHTML.trim();
});

hljs.highlightAll();
</script>

</body>

</html>
